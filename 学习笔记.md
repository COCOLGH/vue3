一、了解相关技术

1. .vue 文件无法在浏览器直接渲染成页面，.vue 文件通过 vue-loader 或者 webpack 等工具将 tempalte 中的内容转为 js 代码如：render h(标签名/组件名, {属性 1： '', 属性 2: '', ...}, [子元素])，才可在浏览器中渲染出页面
   总而言之，.vue 文件中的 tempalte 模板，实际编写的就是 h 函数的实现。h 函数经过编译之后会形成 createVNode 函数代码

2. setup 是 vue3 和 vue2 的最大区别
   setup(props, {slots, attrs, emit}) {

   }

   ref 声明的变量（如： xxx），在 js 中使用时，格式为: xxx.value；在 tempalte 标签中可以直接使用 xxx，因为浏览器在进行编译时，会判断当前变量是否为 ref 声明的，若是则自动将 xxx 变为 xxx.value

3. setup 返回 render 函数的用法

   ```
     const App = defineComponent({
        setup() {
           const state = reactive({
              name: '闭包应用例子'
           })

           const numberRef = ref(1)

           setInterval(() => {
              state.name += '3'
              numberRef.value += 1
           }, 1000)

           const num = numberRef.value //在return函数中使用num时，num永远等于1。原因：setup函数只会执行一次

           return () => {
              const num = numberRef.value // num值会实时更新。原因：numberRef.value值改变会触发return函数的执行；reative声明的函数同理
              return h('div', {id: 'app'}, [
                 h('p', state.name)
              ])
           }
        }
     })
   ```

4. 典型函数闭包的应用：一个函数（setup 函数）在声明时，return 另一个函数，那么 return 的函数可以使用该函数（setup 函数）中申明的所有变量

   ```
      const App = defineComponent({
         setup() {
            const state = reactive({
               name: '闭包应用例子'
            })

            setInterval(() => {
               state.name += '3'
            }, 1000)

            return () => {
               return h('div', {id: 'app'}, [
                  h('p', state.name)
               ])
            }
         }
      })
   ```

5. jsx 解决 ts 编写 h 函数层次不明确，维护困难。比 template 模板编写好处多，如语法校验更严谨，代码编写更灵活等
   https://github.com/vuejs/babel-plugin-jsx 插件官方链接

6. 了解 json schema, 学习可参考网站：https://ajv.js.org/guide/getting-started.html https://json-schema.org/learn/getting-started-step-by-step
   可以校验数据
   前后端通用 json 格式数据，json schema 对应的工具 ajv

7. .eslintignore 配置忽略 eslint 语法校验的文件，如：schema-tests 需要忽略，代码如下：

   ```
      schema-tests
   ```

8. API 设计：接口（props）自定义

   ```jsx
   <JsonSchemaForm
     schema={schema}
     value={value}
     onChange={handleChange}
     locale={locale}
     contextRef={someRef}
     uiSchema={uiSchema}
   />
   ```

   schema：数据格式规范。json schema 对象，用来定义数据，同时也是我们定义表单的依据

   value：表达那的数据结果，你可以从外部改变这个 value，在表单被编辑时，会通过`onChange`透出 value。需要注意的是，因为 vue 使用的是可变数据，如果每次数据变化我们都去改变`value`的对象地址，那么会导致整个表单都需要重新渲染，这会导致性能降低。
   从实践中来看，我们传入的对象，在内部修改其 field 的值基本不会有什么副作用，所以我们会使用这种方式来进行实现。也
   就是说，如果 value"是一个对象，那么从`JsonSchemaForm`内部修改的值，并不会改变`value~对象本身。我们仍然会触发`onChange`，因为可能在表单变化之后，使用者需要进行一些操作。

   locale：语言，使用`ajv-i18n`指定错误信息使用的语言

   onChange: 在表单值有任何变化的时候会触发该回调方法，并把新的值进行返回

   uiSchema：ui 页面交互

   其他...

二、实现 demo

1. monaco-editor: vscode 底层代码编辑器插件，及时在页面查看 schema 和 uiSchema 的效果，-D
2. vue-jss: 可以在 js 中写 css 代码，-S 打包的代码依赖该库
3. 遇到问题，记录一下解决方法 https://blog.csdn.net/qq_44741441/article/details/131688342

三、目录结构

1. .vscode
2. lib：类库代码，真正打包发布出去的代码
3. node_moudules
4. public
5. schema-tests
6. src：demo 代码，不打包发布，用于学习联系的代码
7. tests
