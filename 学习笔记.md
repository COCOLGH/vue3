1. .vue 文件无法在浏览器直接渲染成页面，.vue 文件通过 vue-loader 或者 webpack 等工具将 tempalte 中的内容转为 js 代码如：render h(标签名/组件名, {属性 1： '', 属性 2: '', ...}, [子元素])，才可在浏览器中渲染出页面
   总而言之，.vue 文件中的 tempalte 模板，实际编写的就是 h 函数的实现。h 函数经过编译之后会形成 createVNode 函数代码

2. setup 是 vue3 和 vue2 的最大区别
   setup(props, {slots, attrs, emit}) {

   }

   ref 声明的变量（如： xxx），在 js 中使用时，格式为: xxx.value；在 tempalte 标签中可以直接使用 xxx，因为浏览器在进行编译时，会判断当前变量是否为 ref 声明的，若是则自动将 xxx 变为 xxx.value

3. setup 返回 render 函数的用法

   ```
     const App = defineComponent({
        setup() {
           const state = reactive({
              name: '闭包应用例子'
           })

           const numberRef = ref(1)

           setInterval(() => {
              state.name += '3'
              numberRef.value += 1
           }, 1000)

           const num = numberRef.value //在return函数中使用num时，num永远等于1。原因：setup函数只会执行一次

           return () => {
              const num = numberRef.value // num值会实时更新。原因：numberRef.value值改变会触发return函数的执行；reative声明的函数同理
              return h('div', {id: 'app'}, [
                 h('p', state.name)
              ])
           }
        }
     })
   ```

4. 典型函数闭包的应用：一个函数（setup 函数）在声明时，return 另一个函数，那么 return 的函数可以使用该函数（setup 函数）中申明的所有变量

   ```
      const App = defineComponent({
         setup() {
            const state = reactive({
               name: '闭包应用例子'
            })

            setInterval(() => {
               state.name += '3'
            }, 1000)

            return () => {
               return h('div', {id: 'app'}, [
                  h('p', state.name)
               ])
            }
         }
      })
   ```

5. jsx 解决 ts 编写 h 函数层次不明确，维护困难。比 template 模板编写好处多，如语法校验更严谨，代码编写更灵活等
   https://github.com/vuejs/babel-plugin-jsx 插件官方链接

6. 了解 json schema, 学习可参考网站：https://ajv.js.org/guide/getting-started.html https://json-schema.org/learn/getting-started-step-by-step
   可以校验数据
   前后端通用 json 格式数据，json schema 工具很通用

7. .eslintignore 配置忽略 eslint 语法校验的文件，如：schema-tests 需要忽略，代码如下：

   ```
      schema-tests
   ```
